<div class="smart-memory-settings">
    <!-- æ™ºèƒ½æ€»ç»“æ³¨å…¥å™¨ -->
    <div class="inline-drawer">
        <div class="inline-drawer-header inline-drawer-toggle">
            <b>æ™ºèƒ½æ€»ç»“æ³¨å…¥å™¨-RPGç‰ˆ</b>
            <div class="inline-drawer-icon fa-solid fa-circle-chevron-down"></div>
        </div>
        <div class="inline-drawer-content" style="display: none;">
            <div class="flex-container">
                <!-- AIé…ç½® -->
                <div class="setting-item">
                    <label for="smart_memory_rpg_api_key">APIå¯†é’¥ï¼š</label>
                    <input id="smart_memory_rpg_api_key" type="password" placeholder="è¾“å…¥ä½ çš„APIå¯†é’¥" />
                </div>
                
                <div class="setting-item">
                    <label for="smart_memory_rpg_api_url">APIåœ°å€ï¼š</label>
                    <input id="smart_memory_rpg_api_url" type="text" value="https://api.openai.com/v1" />
                </div>
                
                <div class="setting-item">
                    <button id="get_smart_memory_rpg_models" class="menu_button" style="min-width: 120px;">è·å–æ¨¡å‹åˆ—è¡¨</button>
                    <small style="display: block; margin-top: 5px;">å…ˆå¡«å†™APIå¯†é’¥å’Œåœ°å€ï¼Œç„¶åç‚¹å‡»è·å–</small>
                </div>
                
                <div class="setting-item">
                    <label for="smart_memory_rpg_model">AIæ¨¡å‹ï¼š</label>
                    <select id="smart_memory_rpg_model">
                        <option value="">è¯·å…ˆè·å–æ¨¡å‹åˆ—è¡¨</option>
                    </select>
                    <small id="model_status_rpg" style="color: #888;"></small>
                </div>
                
                <hr class="sysHR">
                
                <!-- æ‰«æè®¾ç½® -->
                <div class="setting-item">
                    <label for="smart_memory_rpg_depth">æ‰«ææ·±åº¦ï¼ˆæœ€è¿‘å‡ æ¡æ¶ˆæ¯ï¼‰ï¼š</label>
                    <input type="range" id="smart_memory_rpg_depth" min="1" max="20" step="1" value="3" />
                    <span id="smart_memory_rpg_depth_value">3</span>
                    <small>ä»…æ‰«ææœ€è¿‘çš„å¯¹è¯æ¶ˆæ¯ï¼ˆåŒ…æ‹¬ç”¨æˆ·å’ŒAIçš„å‘è¨€ï¼‰</small>
                </div>
                
                <div class="setting-item">
                    <label for="smart_memory_rpg_prompt">æ€»ç»“æç¤ºè¯ï¼š</label>
                    <textarea id="smart_memory_rpg_prompt" rows="3" placeholder="å‘Šè¯‰AIå¦‚ä½•æ€»ç»“...">è¯·æ€»ç»“æœ€è¿‘çš„å¯¹è¯è¦ç‚¹ï¼Œæå–é‡è¦ä¿¡æ¯å’Œæƒ…æ„Ÿå˜åŒ–ï¼Œä¿æŒç®€æ´ã€‚</textarea>
                </div>
                
                <hr class="sysHR">
                
                <!-- å¼€å…³è®¾ç½® -->
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="smart_memory_rpg_enabled" checked />
                        å¯ç”¨æ™ºèƒ½æ€»ç»“
                    </label>
                </div>
                
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="smart_memory_rpg_auto_update" checked />
                        è‡ªåŠ¨æ›´æ–°æ€»ç»“
                    </label>
                </div>
                
                <div class="setting-item" id="update_interval_container_rpg">
                    <label for="smart_memory_rpg_update_interval">æ›´æ–°é—´éš”ï¼ˆæ¯Nè½®å¯¹è¯ï¼‰ï¼š</label>
                    <input type="range" id="smart_memory_rpg_update_interval" min="1" max="10" step="1" value="1" />
                    <span id="smart_memory_rpg_update_interval_value">1</span>
                    <small>æ¯å®Œæˆå¤šå°‘è½®å¯¹è¯åè‡ªåŠ¨è§¦å‘æ€»ç»“ï¼ˆä¸€è½® = ç”¨æˆ·+AIï¼‰</small>
                </div>
                
                <hr class="sysHR">
                
                <!-- æ³¨å…¥å†…å®¹é¢„è§ˆ -->
                <div class="sub-section">
                    <h4>æ³¨å…¥å†…å®¹é¢„è§ˆï¼ˆå¯ç¼–è¾‘ï¼‰</h4>
                    <div class="setting-item">
                        <textarea id="smart_memory_rpg_injection_content" placeholder="AIæ€»ç»“çš„å†…å®¹ä¼šæ˜¾ç¤ºåœ¨è¿™é‡Œ...">æš‚æ— æ€»ç»“å†…å®¹</textarea>
                        <small>è¿™äº›å†…å®¹ä¼šä¸å¯¹è¯é¢„è®¾ä¸€èµ·å‘é€ç»™AI</small>
                    </div>
                </div>
                
                <!-- æŒ‰é’® -->
                <div class="setting-item button-group">
                    <button id="test_smart_memory_rpg" class="menu_button" style="min-width: 100px; margin-right: 10px;">ç«‹å³æ€»ç»“</button>
                    <button id="save_smart_memory_rpg_settings" class="menu_button" style="min-width: 100px;">ä¿å­˜è®¾ç½®</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- RPGè®°å¿†å¢å¼ºå™¨ -->
    <div class="inline-drawer">
        <div class="inline-drawer-header inline-drawer-toggle">
            <b>RPGæ¨¡å¼</b>
            <div class="inline-drawer-icon fa-solid fa-circle-chevron-down"></div>
        </div>
        <div class="inline-drawer-content" style="display: none;">
            <div class="rpg-container">
                <!-- æ‰‹æœºç«¯å¿«é€Ÿè¿›å…¥æŒ‰é’® -->
                <div class="rpg-mobile-enter-container" style="display: flex; justify-content: center; margin-bottom: 20px;">
                    <button id="rpg_enter_button" class="menu_button rpg-enter-button" style="
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        font-size: 18px;
                        font-weight: bold;
                        padding: 15px 40px;
                        border: 2px solid white;
                        border-radius: 30px;
                        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
                        cursor: pointer;
                        transition: all 0.3s ease;
                    ">
                        è¿›<br>å…¥
                    </button>
                </div>
                
                <div class="rpg-controls" style="display: flex; flex-direction: column; gap: 10px;">
                    <!-- æ‚¬æµ®æŒ‰é’®å¼€å…³ -->
                    <div class="setting-item" style="margin-bottom: 15px;">
                        <label>
                            <input type="checkbox" id="rpg_floating_enabled" checked />
                            æ˜¾ç¤ºRPGæ‚¬æµ®æŒ‰é’®
                        </label>
                        <small style="display: block; margin-top: 5px;">å…³é—­åæ‚¬æµ®æŒ‰é’®å°†éšè—</small>
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <button id="test_rpg_json" class="menu_button" style="white-space: nowrap;">æµ‹è¯•JSONè§£æ</button>
                    </div>
                    
                    <!-- ä¸»è§’å¤–è§‚é€‰æ‹© -->
                    <div class="setting-item" style="margin-top: 10px;">
                        <label for="rpg_player_sprite">ä¸»è§’å¤–è§‚IDï¼š</label>
                        <select id="rpg_player_sprite" style="width: 200px;">
                            <optgroup label="åŸºç¡€è§’è‰²">
                                <option value="0">å‰‘å£« (0)</option>
                                <option value="1">éª‘å£« (1)</option>
                                <option value="2">å‹‡è€… (2)</option>
                                <option value="10">é­”æ³•å¸ˆ (10)</option>
                                <option value="11">å·«å¸ˆ (11)</option>
                                <option value="12">è´¤è€… (12)</option>
                                <option value="20">å¼“ç®­æ‰‹ (20)</option>
                                <option value="21">ç›—è´¼ (21)</option>
                                <option value="22">åˆºå®¢ (22)</option>
                            </optgroup>
                            <optgroup label="å¹³æ°‘è§’è‰²">
                                <option value="30">æ‘æ°‘ (30)</option>
                                <option value="31">å•†äºº (31)</option>
                                <option value="32">å†œæ°‘ (32)</option>
                            </optgroup>
                            <optgroup label="è´µæ—è§’è‰²">
                                <option value="40">å›½ç‹ (40)</option>
                                <option value="41">å…¬ä¸» (41)</option>
                                <option value="42">è´µæ— (42)</option>
                            </optgroup>
                            <optgroup label="ç¥èŒè§’è‰²">
                                <option value="50">ç‰§å¸ˆ (50)</option>
                                <option value="51">ä¿®å¥³ (51)</option>
                                <option value="52">åœ£éª‘å£« (52)</option>
                            </optgroup>
                            <optgroup label="ç‰¹æ®Šè§’è‰²">
                                <option value="60">ç²¾çµ (60)</option>
                                <option value="61">å…½äºº (61)</option>
                                <option value="62">çŸ®äºº (62)</option>
                                <option value="80">æœºå™¨äºº (80)</option>
                                <option value="81">èµ›åšäºº (81)</option>
                            </optgroup>
                        </select>
                        <button id="apply_player_sprite" class="menu_button" style="margin-left: 10px; white-space: nowrap;">åº”ç”¨</button>
                    </div>
                    
                    <small style="display: block;">æ¸¸æˆä¼šåœ¨æ‚¬æµ®çª—ä¸­æ‰“å¼€ï¼Œç‚¹å‡»å±å¹•æ§åˆ¶ç§»åŠ¨</small>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- RPGæ¸¸æˆçª—å£ä¼šé€šè¿‡JSåŠ¨æ€æ·»åŠ åˆ°body -->

<!-- RPGæ¸¸æˆæ ·å¼ -->
<style>
/* æ¸¸æˆå®¹å™¨æ ·å¼ */
#rpg-game-container {
    position: relative;
    width: 100%;
    max-width: 768px;
    max-height: 640px;
    margin: 0 auto;
    overflow: hidden;
    background: #000;
    border-radius: 8px;
}

/* æ¸¸æˆç”»å¸ƒæ ·å¼ */
#rpg-canvas {
    display: block;
    margin: 0 auto;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
}

/* æ‰‹æœºç«¯ä¼˜åŒ– */
@media (max-width: 768px) {
    #rpg-game-container {
        width: 100vw;
        height: 80vh;
        max-width: none;
        max-height: none;
        border-radius: 0;
    }

    #rpg-floating-window {
        width: 100vw !important;
        height: 100vh !important;
        top: 0 !important;
        left: 0 !important;
        border-radius: 0 !important;
    }
}

/* RPGçª—å£æ ·å¼ä¼˜åŒ– */
#rpg-floating-window {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90vw;
    max-width: 900px;
    height: 80vh;
    max-height: 700px;
    background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
    border: 3px solid #fff;
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.7);
    z-index: 9999;
    overflow: hidden;
}

.rpg-window-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: bold;
}

.rpg-window-close {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    padding: 5px 10px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 14px;
}

.rpg-window-content {
    height: calc(100% - 50px);
    padding: 10px;
    overflow: hidden;
}

/* ä¾§è¾¹æ æ ·å¼ */
.rpg-inventory-panel, .rpg-player-panel, .rpg-event-panel {
    position: absolute;
    background: rgba(44, 62, 80, 0.9);
    color: white;
    border: 2px solid #fff;
    border-radius: 8px;
    padding: 10px;
    font-size: 12px;
    z-index: 10;
}

.rpg-inventory-panel {
    top: 10px;
    right: 10px;
    width: 160px;
    max-height: 200px;
    overflow-y: auto;
}

.rpg-player-panel {
    top: 220px;
    right: 10px;
    width: 160px;
    max-height: 120px;
    overflow-y: auto;
}

.rpg-event-panel {
    bottom: 10px;
    right: 10px;
    width: 160px;
    max-height: 150px;
    overflow-y: auto;
}

.rpg-inventory-title, .rpg-player-title, .rpg-event-title {
    font-weight: bold;
    margin-bottom: 8px;
    color: #ecf0f1;
}

.rpg-inventory-item {
    padding: 2px 0;
    border-bottom: 1px solid rgba(255,255,255,0.2);
}

.rpg-player-text, .rpg-event-text {
    line-height: 1.4;
    color: #ecf0f1;
}

/* æ‰‹æœºç«¯é¢æ¿è°ƒæ•´ */
@media (max-width: 768px) {
    .rpg-inventory-panel, .rpg-player-panel, .rpg-event-panel {
        position: relative;
        width: 100%;
        margin-bottom: 10px;
        right: auto;
        top: auto;
        bottom: auto;
    }

    #rpg-game-container {
        order: -1;
    }
}
</style>

<!-- åŠ è½½Phaseråº“ -->
<script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>

<script>
// RPGæ¸¸æˆä»£ç 
window.RPGMemoryGame = {
    game: null,
    scene: null,
    playerSpriteId: 0,  // å­˜å‚¨ç©å®¶é€‰æ‹©çš„ç²¾çµID
    
    // è·å–ç©å®¶ç²¾çµID
    getPlayerSpriteId: function() {
        // ç›´æ¥è¿”å›å­˜å‚¨çš„å€¼
        return this.playerSpriteId || 0;  // é»˜è®¤ä½¿ç”¨0å·è§’è‰²
    },
    
    // è®¾ç½®ç©å®¶ç²¾çµIDï¼ˆä»å¤–éƒ¨è°ƒç”¨ï¼‰
    setPlayerSpriteId: function(id) {
        this.playerSpriteId = id;
    },
    
    // æ›´æ–°ç©å®¶å¤–è§‚
    updatePlayerSprite: function(spriteId) {
        if (this.scene && this.scene.player) {
            this.scene.player.setFrame(spriteId);
            console.log('æ›´æ–°ç©å®¶å¤–è§‚ä¸ºID:', spriteId);
        }
    },
    
    init: function() {
        if (this.game) {
            this.destroy(); // å…ˆé”€æ¯æ—§æ¸¸æˆå®ä¾‹
        }
        
        const RESOURCE_SERVER = 'https://www.lingxiai.fun';
        
        class RPGMemoryScene extends Phaser.Scene {
            constructor() {
                super({ key: 'RPGMemoryScene' });
                this.npcs = [];
                this.inventory = [];
                this.dynamicNPCs = {};
            }
            
            preload() {
                this.load.setBaseURL(RESOURCE_SERVER);
                this.load.setCORS('anonymous');
                
                // åŠ è½½tilemap JSON - ä½¿ç”¨è½¬æ¢åçš„åœ°å›¾
                this.load.tilemapTiledJSON('map', 'maps/phaser_ready_map.json');
                
                // åŠ è½½tilesetå›¾ç‰‡ - ä½¿ç”¨æœåŠ¡å™¨ä¸Šå®é™…çš„æ–‡ä»¶
                this.load.image('tileset1', 'maps/Interiors_free_16x16.png');
                this.load.image('tileset2', 'maps/icecream_shop_layer2.png');
                this.load.image('background', 'maps/icecream_shop_layer1.png');
                
                // åŠ è½½è§’è‰²ç²¾çµ
                this.load.spritesheet('characters', 'sprites/characters.png', {
                    frameWidth: 16,  // æ­£ç¡®çš„å®½åº¦
                    frameHeight: 32  // æ­£ç¡®çš„é«˜åº¦
                });
                
                this.load.on('loaderror', (file) => {
                    console.warn('èµ„æºåŠ è½½å¤±è´¥:', file.key);
                    this.createFallbackSprite(file.key);
                });
                
                // åˆå§‹åŒ–ç§»åŠ¨ç›®æ ‡
                this.moveTarget = null;
            }
            
            create() {
                // åˆ›å»ºtilemap
                const map = this.make.tilemap({ key: 'map' });
                
                // è®¾ç½®ä¸–ç•Œè¾¹ç•Œä¸ºåœ°å›¾å¤§å° (ä¸è¦ä¹˜ä»¥4)
                this.physics.world.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
                
                // ä¿å­˜åœ°å›¾å¼•ç”¨
                this.map = map;
                
                // è®¾ç½®ç›¸æœºè¾¹ç•Œ (ä¸è¦ä¹˜ä»¥4ï¼Œzoomä¼šè‡ªåŠ¨å¤„ç†)
                this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
                
                // æ¸²æŸ“èƒŒæ™¯å›¾åƒå±‚
                const imageLayers = map.imageLayers;
                // ç›´æ¥æ·»åŠ èƒŒæ™¯å›¾ç‰‡
                const bg = this.add.image(0, 0, 'background').setOrigin(0, 0);
                
                // æ·»åŠ tilesets - nameå¿…é¡»åŒ¹é…ï¼Œä½†imageä½¿ç”¨PhaseråŠ è½½çš„key
                const tileset1 = map.addTilesetImage('1', 'tileset1');
                const tileset2 = map.addTilesetImage('2', 'tileset2');
                
                // è°ƒè¯•è¾“å‡º
                console.log('Tileset1:', tileset1);
                console.log('Tileset2:', tileset2);
                
                // åˆ›å»ºå›¾å—å±‚
                const layer = map.createLayer('å›¾å—å±‚ 1', [tileset1, tileset2], 0, 0);
                if (layer) {
                    layer.setVisible(true);
                }
                
                // è·å–ç”¨æˆ·è®¾ç½®çš„ä¸»è§’IDï¼ˆä»æ‰©å±•è®¾ç½®ä¸­è¯»å–ï¼‰
                const playerSpriteId = window.RPGMemoryGame.getPlayerSpriteId();
                
                // åˆ›å»ºç©å®¶ - ä½¿ç”¨é€‰æ‹©çš„è§’è‰²å¤–è§‚
                this.player = this.physics.add.sprite(96, 80, 'characters', playerSpriteId);
                this.player.setScale(1);  // ä¸éœ€è¦ç¼©æ”¾ï¼Œzoomä¼šå¤„ç†
                this.player.setCollideWorldBounds(true);
                this.player.setDepth(10);
                
                // è®¾ç½®ç©å®¶ç¢°æ’ä½“ - æ›´å°ä»¥ä¾¿é€šè¿‡çª„é€šé“
                this.player.body.setSize(8, 8);
                this.player.body.setOffset(4, 4);
                
                // è®¾ç½®ç›¸æœºè·Ÿéšç©å®¶
                this.cameras.main.startFollow(this.player);
                
                // åˆ›å»ºç¢°æ’ç³»ç»Ÿ
                this.createCollisions();
                
                // åˆ›å»ºåŠ¨ç”»ï¼ˆå¦‚æœæœ‰å¤šå¸§ï¼‰
                // characters.pngæ˜¯ä¸€ä¸ªå¤§çš„ç²¾çµè¡¨ï¼ŒåŒ…å«å¤šä¸ªè§’è‰²
                // æ¯ä¸ªè§’è‰²å æ®å›¾ç‰‡ä¸­çš„ä¸€ä¸ªæ ¼å­ï¼Œä¸æ˜¯åŠ¨ç”»å¸§
                
                // ç§»é™¤é”®ç›˜æ§åˆ¶ï¼Œåªä½¿ç”¨ç‚¹å‡»/è§¦æ‘¸ç§»åŠ¨
                // this.cursors = this.input.keyboard.createCursorKeys();  // å·²ç¦ç”¨
                
                // æ·»åŠ ç‚¹å‡»/è§¦æ‘¸ç§»åŠ¨åŠŸèƒ½ï¼ˆæ‰‹æœºç«¯æ”¯æŒï¼‰
                this.input.on('pointerdown', (pointer) => {
                    // ç¡®ä¿æ˜¯ä¸»è¦æŒ‰é’®æˆ–è§¦æ‘¸
                    if (pointer.button !== 0) return;

                    // å°†å±å¹•åæ ‡è½¬æ¢ä¸ºæ¸¸æˆä¸–ç•Œåæ ‡
                    const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);

                    // ç¡®ä¿ç‚¹å‡»ä½ç½®åœ¨æ¸¸æˆä¸–ç•ŒèŒƒå›´å†…
                    if (worldPoint.x < 0 || worldPoint.x > this.map.widthInPixels ||
                        worldPoint.y < 0 || worldPoint.y > this.map.heightInPixels) {
                        return;
                    }

                    // è®¾ç½®ç§»åŠ¨ç›®æ ‡
                    this.moveTarget = {
                        x: worldPoint.x,
                        y: worldPoint.y
                    };

                    // åˆ›å»ºç‚¹å‡»æŒ‡ç¤ºå™¨ï¼ˆå¯é€‰ï¼‰
                    if (this.clickMarker) {
                        this.clickMarker.destroy();
                    }
                    this.clickMarker = this.add.circle(worldPoint.x, worldPoint.y, 2, 0x00ff00, 0.8);
                    this.clickMarker.setDepth(1);

                    // 1ç§’åç§»é™¤æŒ‡ç¤ºå™¨
                    this.time.delayedCall(1000, () => {
                        if (this.clickMarker) {
                            this.clickMarker.destroy();
                            this.clickMarker = null;
                        }
                    });
                });
                
                // ä¿å­˜åœºæ™¯å¼•ç”¨
                window.RPGMemoryGame.scene = this;
                
                // è§¦å‘åœºæ™¯å‡†å¤‡å®Œæˆäº‹ä»¶
                console.log('RPGåœºæ™¯å·²åˆå§‹åŒ–å®Œæˆ');
                if (window.RPGMemoryGame.onSceneReady) {
                    window.RPGMemoryGame.onSceneReady();
                }
            }
            
            createCollisions() {
                // åªä½¿ç”¨åœ°å›¾è¾¹ç•Œç¢°æ’ï¼Œä¸è¦å†…éƒ¨éšœç¢ç‰©
                const objectLayers = this.map.objects;
                console.log('æŸ¥æ‰¾åœ°å›¾è¾¹ç•Œ...');
                
                if (objectLayers && objectLayers.length > 0) {
                    // æŸ¥æ‰¾äº‹ä»¶å±‚
                    const eventLayer = objectLayers.find(layer => layer.name === 'äº‹ä»¶å±‚');
                    if (eventLayer && eventLayer.objects) {
                        const boundary = eventLayer.objects.find(obj => obj.name === 'åœ°å›¾è¾¹ç•Œ');
                        if (boundary) {
                            // è®¾ç½®ç‰©ç†ä¸–ç•Œè¾¹ç•Œ
                            this.physics.world.setBounds(
                                boundary.x,
                                boundary.y,
                                boundary.width,
                                boundary.height
                            );
                            console.log('åœ°å›¾è¾¹ç•Œ:', boundary.x, boundary.y, boundary.width, boundary.height);
                        }
                    }
                }
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è¾¹ç•Œï¼Œä½¿ç”¨é»˜è®¤åœ°å›¾å¤§å°
                if (!this.physics.world.bounds) {
                    this.physics.world.setBounds(0, 0, this.map.widthInPixels, this.map.heightInPixels);
                    console.log('ä½¿ç”¨é»˜è®¤åœ°å›¾è¾¹ç•Œ');
                }
                
                // è®¾ç½®ç©å®¶ç¢°æ’ä¸–ç•Œè¾¹ç•Œ
                if (this.player) {
                    this.player.setCollideWorldBounds(true);
                }
            }
            
            createFallbackSprite(key) {
                // å¦‚æœèµ„æºåŠ è½½å¤±è´¥ï¼Œåˆ›å»ºå¤‡ç”¨ç²¾çµ
                console.log('åˆ›å»ºå¤‡ç”¨ç²¾çµ:', key);
                if (!this.textures.exists(key)) {
                    const graphics = this.make.graphics();
                    const color = 0x888888;
                    graphics.fillStyle(color);
                    
                    if (key === 'characters') {
                        graphics.fillRect(0, 0, 16, 32);
                        graphics.generateTexture(key, 16, 32);
                    } else {
                        graphics.fillRect(0, 0, 16, 16);
                        graphics.generateTexture(key, 16, 16);
                    }
                    graphics.destroy();
                }
            }
            
            updateFromJSON(rpgData) {
                console.log('RPGæ•°æ®æ›´æ–°:', rpgData);
                
                // å¤„ç†ä¸»è§’æ•°æ®
                if (rpgData.player) {
                    this.updatePlayerDialogue(rpgData.player);
                }
                
                // æ›´æ–°NPC - è¿‡æ»¤æ‰ä¸»è§’
                if (rpgData.npcs && Array.isArray(rpgData.npcs)) {
                    // è·å–å½“å‰è§’è‰²åï¼ˆä»å…¨å±€è·å–ï¼‰
                    let playerName = "ä¸»è§’";
                    try {
                        // å°è¯•ä»getContextè·å–
                        if (window.parent && window.parent.getContext) {
                            const context = window.parent.getContext();
                            playerName = context?.name2 || context?.name || "ä¸»è§’";
                        }
                    } catch (e) {
                        console.log('æ— æ³•è·å–ä¸»è§’åç§°ï¼Œä½¿ç”¨é»˜è®¤å€¼');
                    }
                    
                    // ä¸»è§’åˆ«ååˆ—è¡¨
                    const ä¸»è§’åˆ«å = ['ä¸»è§’', 'ç©å®¶', 'ä½ ', 'player', 'you', playerName];
                    
                    // è¿‡æ»¤æ‰åå­—ä¸ä¸»è§’ç›¸åŒçš„NPCï¼ˆåŒ…æ‹¬åŒ…å«ä¸»è§’å…³é”®è¯çš„ï¼‰
                    const filteredNPCs = rpgData.npcs.filter(npc => {
                        // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸»è§’å…³é”®è¯
                        const isPlayer = ä¸»è§’åˆ«å.some(alias => {
                            if (!npc.name) return false;
                            const nameLower = npc.name.toLowerCase();
                            const aliasLower = alias.toLowerCase();
                            // å®Œå…¨åŒ¹é…æˆ–åŒ…å«ä¸»è§’å…³é”®è¯ï¼ˆå¦‚"ä¸»è§’(xxx)"ï¼‰
                            return nameLower === aliasLower || 
                                   nameLower.includes(aliasLower + '(') || 
                                   nameLower.startsWith(aliasLower);
                        });
                        return !isPlayer;
                    });
                    
                    console.log(`æ›´æ–°${filteredNPCs.length}ä¸ªNPCï¼ˆè¿‡æ»¤æ‰ä¸»è§’ï¼‰`);
                    // æ¸…é™¤æ—§NPC
                    Object.values(this.dynamicNPCs).forEach(npc => {
                        if (npc.sprite) npc.sprite.destroy();
                        if (npc.nameText) npc.nameText.destroy();
                    });
                    this.dynamicNPCs = {};
                    
                    // æ·»åŠ æ–°NPC
                    filteredNPCs.forEach(npcData => {
                        this.addDynamicNPC(npcData);
                    });
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰ä¸»è§’æ•°æ®ï¼ˆåœ¨è¿‡æ»¤æ‰çš„NPCä¸­æŸ¥æ‰¾ï¼‰
                    const playerNPC = rpgData.npcs.find(npc => {
                        if (!npc.name) return false;
                        const nameLower = npc.name.toLowerCase();
                        return ä¸»è§’åˆ«å.some(alias => {
                            const aliasLower = alias.toLowerCase();
                            // å®Œå…¨åŒ¹é…æˆ–åŒ…å«ä¸»è§’å…³é”®è¯ï¼ˆå¦‚"ä¸»è§’(xxx)"ï¼‰
                            return nameLower === aliasLower || 
                                   nameLower.includes(aliasLower + '(') || 
                                   nameLower.startsWith(aliasLower);
                        });
                    });
                    
                    if (playerNPC && !rpgData.player) {
                        // å¦‚æœæ‰¾åˆ°ä¸»è§’NPCä½†æ²¡æœ‰playeræ•°æ®ï¼Œå°†å…¶è½¬æ¢ä¸ºplayer
                        this.updatePlayerDialogue(playerNPC);
                    }
                }
                
                // æ›´æ–°èƒŒåŒ…
                if (rpgData.inventory) {
                    this.updateInventory(rpgData.inventory);
                }
                
                // æ›´æ–°äº‹ä»¶
                if (rpgData.events) {
                    this.updateEvents(rpgData.events);
                }
            }
            
            addDynamicNPC(npcData) {
                if (this.dynamicNPCs[npcData.id]) {
                    const existingNPC = this.dynamicNPCs[npcData.id];
                    existingNPC.data = npcData;
                    if (existingNPC.nameText) {
                        existingNPC.nameText.setText(npcData.name || '???');
                    }
                    return;
                }
                
                // ç›´æ¥ä½¿ç”¨spriteIdä½œä¸ºå¸§ç´¢å¼•
                const spriteId = npcData.spriteId || 0;
                const npcSprite = this.physics.add.sprite(
                    npcData.x || Phaser.Math.Between(50, 150),
                    npcData.y || Phaser.Math.Between(50, 120),
                    'characters',
                    spriteId  // ç›´æ¥ä½¿ç”¨spriteIdé€‰æ‹©è§’è‰²
                );
                
                npcSprite.setScale(1);  // ä¸éœ€è¦ç¼©æ”¾
                npcSprite.setDepth(5);
                
                // è®¾ç½®NPCç¢°æ’ä½“å’Œè¾¹ç•Œ
                npcSprite.setCollideWorldBounds(true);
                npcSprite.body.setSize(8, 8);
                npcSprite.body.setOffset(4, 4);
                
                // åˆå§‹åŒ–éšæœºç§»åŠ¨
                npcSprite.moveTimer = 0;
                npcSprite.moveDirection = { x: 0, y: 0 };
                npcSprite.nextMoveChange = Phaser.Math.Between(1000, 3000);
                
                const nameText = this.add.text(
                    npcSprite.x,
                    npcSprite.y - 25,
                    npcData.name || '???',
                    {
                        fontSize: '12px',
                        fill: '#ffffff',
                        backgroundColor: '#000000',
                        padding: { x: 2, y: 1 }
                    }
                );
                nameText.setOrigin(0.5);
                nameText.setDepth(15);
                
                npcSprite.setInteractive();
                npcSprite.on('pointerdown', () => {
                    this.showDialogue(npcData);
                });
                
                this.dynamicNPCs[npcData.id] = {
                    sprite: npcSprite,
                    nameText: nameText,
                    data: npcData
                };
            }
            
            showDialogue(npcData) {
                // è®¡ç®—å¯¹è¯æ¡†é«˜åº¦ï¼ˆæ ¹æ®æ–‡å­—é•¿åº¦è‡ªé€‚åº”ï¼‰
                const dialogue = npcData.dialogue || '...';
                const maxWidth = 160;
                const fontSize = 10;
                const lineHeight = fontSize * 1.4;

                // åˆ›å»ºä¸´æ—¶æ–‡æœ¬æ¥æµ‹é‡å®é™…å°ºå¯¸
                const tempText = this.add.text(0, 0,
                    `${npcData.name} ${npcData.emotion === 'happy' ? 'ğŸ˜Š' :
                                      npcData.emotion === 'sad' ? 'ğŸ˜¢' :
                                      npcData.emotion === 'angry' ? 'ğŸ˜ ' : 'ğŸ˜'}\n${dialogue}`,
                    {
                        fontSize: `${fontSize}px`,
                        wordWrap: { width: maxWidth },
                        fontFamily: 'Arial, sans-serif'
                    }
                );

                // è·å–å®é™…æ–‡æœ¬å°ºå¯¸
                const textBounds = tempText.getBounds();
                const actualWidth = Math.min(textBounds.width + 20, 180); // æœ€å¤§180åƒç´ ï¼ŒåŠ 20åƒç´ å†…è¾¹è·
                const actualHeight = textBounds.height + 20; // åŠ 20åƒç´ å†…è¾¹è·
                tempText.destroy(); // é”€æ¯ä¸´æ—¶æ–‡æœ¬

                // å¯¹è¯æ¡†ä½ç½®è·ŸéšNPC
                const npcSprite = this.dynamicNPCs[npcData.id]?.sprite;
                let dialogX = 96; // é»˜è®¤ä¸­å¿ƒä½ç½®
                let dialogY = 120;

                if (npcSprite) {
                    // å°†å¯¹è¯æ¡†æ”¾åœ¨NPCä¸Šæ–¹
                    dialogX = npcSprite.x;
                    dialogY = npcSprite.y - 40; // NPCä¸Šæ–¹40åƒç´ 

                    // ç¡®ä¿å¯¹è¯æ¡†ä¸è¶…å‡ºå±å¹•è¾¹ç•Œ
                    dialogX = Phaser.Math.Clamp(dialogX, actualWidth/2 + 10, 192 - actualWidth/2 - 10);
                    dialogY = Phaser.Math.Clamp(dialogY, actualHeight/2 + 10, 160 - actualHeight/2 - 10);
                }

                // åˆ›å»ºåœ†è§’å¯¹è¯æ¡†èƒŒæ™¯
                const dialogBg = this.add.graphics();
                dialogBg.fillStyle(0x2c3e50, 0.95); // æ·±è“ç°è‰²èƒŒæ™¯
                dialogBg.fillRoundedRect(
                    dialogX - actualWidth/2,
                    dialogY - actualHeight/2,
                    actualWidth,
                    actualHeight,
                    8 // åœ†è§’åŠå¾„
                );

                // æ·»åŠ ç™½è‰²è¾¹æ¡†
                dialogBg.lineStyle(2, 0xffffff, 1);
                dialogBg.strokeRoundedRect(
                    dialogX - actualWidth/2,
                    dialogY - actualHeight/2,
                    actualWidth,
                    actualHeight,
                    8
                );

                dialogBg.setDepth(20);

                const emotion = npcData.emotion === 'happy' ? 'ğŸ˜Š' :
                               npcData.emotion === 'sad' ? 'ğŸ˜¢' :
                               npcData.emotion === 'angry' ? 'ğŸ˜ ' : 'ğŸ˜';

                // NPCå¯¹è¯æ¡†å­—ä½“ - ä½¿ç”¨å®é™…æµ‹é‡çš„ä½ç½®
                const dialogText = this.add.text(dialogX, dialogY,
                    `${npcData.name} ${emotion}\n${dialogue}`,
                    {
                        fontSize: `${fontSize}px`,
                        fill: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: 1,
                        wordWrap: { width: maxWidth },
                        align: 'center',
                        fontFamily: 'Arial, sans-serif',
                        lineSpacing: 4
                    }
                );
                dialogText.setOrigin(0.5);
                dialogText.setDepth(21);

                // æ ¹æ®æ–‡å­—é•¿åº¦è°ƒæ•´æ˜¾ç¤ºæ—¶é—´
                const displayTime = Math.min(3000 + dialogue.length * 30, 6000); // æœ€å¤š6ç§’

                this.time.delayedCall(displayTime, () => {
                    dialogBg.destroy();
                    dialogText.destroy();
                });
            }
            
            updateInventory(inventory) {
                const inventoryList = document.getElementById('rpg-inventory-list');
                if (inventoryList) {
                    inventoryList.innerHTML = '';
                    inventory.forEach(item => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'rpg-inventory-item';
                        itemDiv.textContent = `${item.name} x${item.quantity || 1}`;
                        inventoryList.appendChild(itemDiv);
                    });
                }
            }
            
            updateEvents(events) {
                const eventText = document.getElementById('rpg-event-text');
                if (eventText) {
                    let text = '';
                    if (events.current) {
                        text += `å½“å‰: ${events.current}\n`;
                    }
                    if (events.permanent) {
                        text += `æ°¸ä¹…è®°å¿†: ${events.permanent}`;
                    }
                    eventText.textContent = text || 'ç­‰å¾…äº‹ä»¶æ›´æ–°...';
                }
            }
            
            updatePlayerDialogue(playerData) {
                const playerText = document.getElementById('rpg-player-text');
                if (playerText && playerData) {
                    const emotion = playerData.emotion === 'happy' ? 'ğŸ˜Š' : 
                                  playerData.emotion === 'sad' ? 'ğŸ˜¢' : 
                                  playerData.emotion === 'angry' ? 'ğŸ˜ ' : 'ğŸ˜';
                    
                    const dialogue = playerData.dialogue || 'ç­‰å¾…ä¸»è§’è¯´è¯...';
                    const status = playerData.status || '';
                    
                    // æ˜¾ç¤ºä¸»è§’å°è¯å’ŒçŠ¶æ€
                    let displayText = `${emotion} ${dialogue}`;
                    if (status) {
                        displayText += `\n[çŠ¶æ€: ${status}]`;
                    }
                    playerText.textContent = displayText;
                    
                    console.log(`æ›´æ–°ä¸»è§’å°è¯: ${dialogue}`);
                    if (status) {
                        console.log(`ä¸»è§’çŠ¶æ€: ${status}`);
                    }
                }
            }
            
            update() {
                if (!this.player) return;
                
                const speed = 100;  // ä½¿ç”¨æ­£å¸¸çš„ç‰©ç†é€Ÿåº¦
                let velocityX = 0;
                let velocityY = 0;
                
                // æ£€æŸ¥ç‚¹å‡»/è§¦æ‘¸ç§»åŠ¨
                if (this.moveTarget) {
                    const distance = Phaser.Math.Distance.Between(
                        this.player.x, this.player.y,
                        this.moveTarget.x, this.moveTarget.y
                    );
                    
                    if (distance > 5) {  // å¦‚æœè·ç¦»ç›®æ ‡è¶…è¿‡5åƒç´ 
                        // è®¡ç®—ç§»åŠ¨æ–¹å‘
                        const angle = Phaser.Math.Angle.Between(
                            this.player.x, this.player.y,
                            this.moveTarget.x, this.moveTarget.y
                        );
                        
                        velocityX = Math.cos(angle) * speed;
                        velocityY = Math.sin(angle) * speed;
                        
                        // æ›´æ–°æœå‘
                        this.player.setFlipX(velocityX < 0);
                    } else {
                        // åˆ°è¾¾ç›®æ ‡ï¼Œåœæ­¢ç§»åŠ¨
                        this.moveTarget = null;
                    }
                }
                
                // é”®ç›˜æ§åˆ¶å·²ç§»é™¤ï¼Œé¿å…ä¸ç³»ç»ŸåŠŸèƒ½å†²çª
                // åªä½¿ç”¨ç‚¹å‡»/è§¦æ‘¸ç§»åŠ¨
                
                // åº”ç”¨é€Ÿåº¦
                this.player.setVelocityX(velocityX);
                this.player.setVelocityY(velocityY);
                
                // ä¸éœ€è¦åŠ¨ç”»ï¼Œå› ä¸ºcharacters.pngæ˜¯é™æ€è§’è‰²é›†åˆ
                
                // æ›´æ–°NPCåå­—ä½ç½®å’Œéšæœºç§»åŠ¨
                Object.values(this.dynamicNPCs).forEach(npc => {
                    if (npc.sprite) {
                        // æ›´æ–°åå­—ä½ç½®
                        if (npc.nameText) {
                            npc.nameText.x = npc.sprite.x;
                            npc.nameText.y = npc.sprite.y - 25;
                        }
                        
                        // NPCéšæœºç§»åŠ¨
                        npc.sprite.moveTimer += 16; // çº¦16msä¸€å¸§
                        
                        if (npc.sprite.moveTimer >= npc.sprite.nextMoveChange) {
                            // æ”¹å˜ç§»åŠ¨æ–¹å‘
                            npc.sprite.moveTimer = 0;
                            npc.sprite.nextMoveChange = Phaser.Math.Between(1000, 3000);
                            
                            // éšæœºé€‰æ‹©æ–°æ–¹å‘æˆ–åœæ­¢
                            const choice = Phaser.Math.Between(0, 4);
                            switch(choice) {
                                case 0: // åœæ­¢
                                    npc.sprite.moveDirection = { x: 0, y: 0 };
                                    break;
                                case 1: // å‘å·¦
                                    npc.sprite.moveDirection = { x: -1, y: 0 };
                                    npc.sprite.setFlipX(true);
                                    break;
                                case 2: // å‘å³
                                    npc.sprite.moveDirection = { x: 1, y: 0 };
                                    npc.sprite.setFlipX(false);
                                    break;
                                case 3: // å‘ä¸Š
                                    npc.sprite.moveDirection = { x: 0, y: -1 };
                                    break;
                                case 4: // å‘ä¸‹
                                    npc.sprite.moveDirection = { x: 0, y: 1 };
                                    break;
                            }
                        }
                        
                        // åº”ç”¨ç§»åŠ¨é€Ÿåº¦ï¼ˆæ¯”ç©å®¶æ…¢ï¼‰
                        const npcSpeed = 30;
                        npc.sprite.setVelocityX(npc.sprite.moveDirection.x * npcSpeed);
                        npc.sprite.setVelocityY(npc.sprite.moveDirection.y * npcSpeed);
                        
                        // æ£€æµ‹ä¸ç©å®¶çš„ç¢°æ’ï¼ˆé¿å…é‡å ï¼‰
                        if (this.player) {
                            const distance = Phaser.Math.Distance.Between(
                                npc.sprite.x, npc.sprite.y,
                                this.player.x, this.player.y
                            );
                            
                            // å¦‚æœå¤ªè¿‘ï¼Œæ¨å¼€NPC
                            if (distance < 20) {
                                const angle = Phaser.Math.Angle.Between(
                                    this.player.x, this.player.y,
                                    npc.sprite.x, npc.sprite.y
                                );
                                npc.sprite.x += Math.cos(angle) * 2;
                                npc.sprite.y += Math.sin(angle) * 2;
                            }
                        }
                    }
                });
            }
        }
        
        // æ ¹æ®å±å¹•å¤§å°é€‰æ‹©åˆé€‚çš„ç¼©æ”¾å€æ•°
        const isMobile = window.innerWidth <= 768;
        let zoom;

        if (isMobile) {
            // æ‰‹æœºç«¯ä½¿ç”¨è¾ƒå°çš„ç¼©æ”¾ï¼Œç¡®ä¿åœ°å›¾å®Œæ•´æ˜¾ç¤º
            zoom = 2;  // æ‰‹æœºç«¯2å€ç¼©æ”¾ (æœ€ç»ˆæ˜¾ç¤º384Ã—320)
        } else {
            // æ¡Œé¢ç«¯ä½¿ç”¨4å€ç¼©æ”¾
            zoom = 4;  // æ¡Œé¢ç«¯4å€ç¼©æ”¾ (æœ€ç»ˆæ˜¾ç¤º768Ã—640)
        }

        console.log(`RPGæ¸¸æˆé…ç½®: ${isMobile ? 'æ‰‹æœºç«¯' : 'æ¡Œé¢ç«¯'}æ¨¡å¼ï¼Œä½¿ç”¨${zoom}å€ç¼©æ”¾`);

        // æ¸¸æˆé…ç½® - æŒ‰ç…§è§„èŒƒä½¿ç”¨zoomç¼©æ”¾
        const config = {
            type: Phaser.CANVAS,
            width: 192,  // åœ°å›¾å®é™…å®½åº¦: 12æ ¼ Ã— 16åƒç´ 
            height: 160,  // åœ°å›¾å®é™…é«˜åº¦: 10æ ¼ Ã— 16åƒç´ 
            parent: 'rpg-game-container',
            canvas: document.getElementById('rpg-canvas'),
            pixelArt: true,  // åƒç´ å®Œç¾æ¸²æŸ“
            zoom: zoom,  // å›ºå®šç¼©æ”¾æ˜¾ç¤º
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: [RPGMemoryScene]
        };

        
        this.game = new Phaser.Game(config);
    },
    
    updateRPG: function(rpgData) {
        console.log('RPGMemoryGame.updateRPGè¢«è°ƒç”¨:', rpgData);
        if (this.scene) {
            this.scene.updateFromJSON(rpgData);
        } else {
            console.log('åœºæ™¯æœªåˆå§‹åŒ–ï¼Œç¼“å­˜æ•°æ®ç­‰å¾…åœºæ™¯å°±ç»ª');
            // ç¼“å­˜æ•°æ®ï¼Œç­‰åœºæ™¯å‡†å¤‡å¥½åå†æ›´æ–°
            this.pendingData = rpgData;
        }
    },
    
    // åœºæ™¯å‡†å¤‡å®Œæˆçš„å›è°ƒ
    onSceneReady: function() {
        if (this.pendingData) {
            console.log('åœºæ™¯å·²å°±ç»ªï¼Œåº”ç”¨ç¼“å­˜çš„RPGæ•°æ®');
            this.scene.updateFromJSON(this.pendingData);
            this.pendingData = null;
        }
    },
    
    destroy: function() {
        if (this.game) {
            this.game.destroy(true);
            this.game = null;
            this.scene = null;
        }
    }
};
</script>